"use strict";

/* GENERAL EXPLANATION:

-> CODE :
const abuzar = {
  firstName: "Abuzar",
  year: 2003,

  calcAge: function () {
    console.log(this);
    console.log(2030 - this.year);

    const self = this;

    const innerFunction = function () {
      console.log(this);
      console.log(self);
    };
    innerFunction();
  },
};

abuzar.calcAge();


-> WE CAN CREATE A VARIABLE INSIDE THE OBJECT METHOD AND ASSIGN IT THE "this" KEYWORD.

-> WE CAN THEN USE THAT VARIABLE  INSIDE THE CHILD OR INNER FUNCTION OF THAT METHOD.

-> THE VARIABLE WILL POINT THE METHOD OBJECT ITSELF AND CAN USE THE PROPERTY OF IT.

-> THIS IS A WAY IN WHICH WE CAN PRESERVE THE "this" KEYWORD AND WE CAN USE THAT AS WELL.

-> THIS WAS THE KIND OF PRE ES6 SOLUTION.

-> BUT IF WE WANT TO CONSOLE THE "this" DIRECTLY INTO THE INNER FUNCTION , THEN IT WILL BE UNDEFINED .

-> BECAUSE THE FUNCTIONS INSIDE THE METHOD ARE SIMPLE FUNCTIONS , THE FUNCTION WHICH IS OUTSIDE ANY OBJECT WILL GIVE UNDEFINED VALUE OF "this".

-> THE SOLUTION FOR THIS IS , WE CAN CREATE AN ARROW FUNCTION INSIDE A METHOD INSTEAD OF SIMPLE FUNCTION .
-> ARROW FUNCTION DOESN'T GET THERE OWN "this" , IT USES THE "this" OF THIER PARENT SCOPE .
-> SO IN A RESULT THE "this" WILL BE THE OBJECT ITSELF OF THAT METHOD.
-> IT INHERITS THE "this" FROM THE PARENT SCOPE.


-> BUT THE ARROW FUNCTIONS ALSO CAN CREATE SOME PROBLEMS.
-> DIRECTLY USE ARROW FUNCTION INSIDE THE OBJECT AND USING "this" KEYWORD IN IT WILL DIRECTLY POINTS TO THE WINDOW GLOBAL OBJECT .
-> THIS IS WHY WE SHOULDN'T USE THE ARROW FUNCTIONS AS METHODS EVEN IF IT IS NOT ABOUT THE "this" KEYWORD AND ALSO VAR.

var myname = "Abuzar";

const obj = {
  myname: "Raziq",

  greet: () => {
    console.log(this);
    console.log(this.myname);
  },
};

obj.greet();


*/

/*

#

*/

/* THE ARGUMENTS KEYWORD:
const addExp = function (a, b) {
  console.log(arguments);
  return a + b;
};

-> IT IS LEGAL TO ADD MORE ARGUMENTS THAN GIVEN PARAMETERS.
-> IT IS ALSO USEFUL WHEN WE WANT TO USE LOOP.


-> ARROW FUNCTION DOESN'T GET THE ARGUMENTS KEYWORD.

const addExpArrow = (a, b) => {
  console.log(arguments);
  return a + b;
};
addExpArrow();


*/

/*

#

*/

/* SUMMARY:

-> IN PRE-ES6 WE HAVE TO FIRST ASSIGN THE "this" KEYWORD TO A VARIABLE AND THEN USE IT INSIDE THE METHOD FUNCTION IN AN OBJECT.
-> THAT "this" THEN POINTED THE OBJECT ITSELF.
-> BUT USING "this" DIRECTLY WILL GET UNDEFINED BECAUSE OF SIMPLE FUNCTION.


-> THEN IN ES6 WE HAVE ARROW FUNCTIONS.
-> WE CAN USE "this" DIRECTLY INSIDE THE ARROW FUNCTION OF A METHOD OF AN OBJECT . IT WILL INHERIT THAT "this" FROM THAT METHOD.

-> BUT WE CANNOT USE ARROW FUNCTIONS DIRECTLY IN THE OBJECT.
-> BECAUSE THE "this" WILL BE THEN THE OUTER WINDOW OBJECT.
-> THIS WILL LEAD TO BIG PRBLEMS AND ALSO USE OF VAR.

*/
