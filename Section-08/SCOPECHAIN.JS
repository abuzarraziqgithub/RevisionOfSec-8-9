"use strict";

/* GENERAL EXPLANATION:

-> START WITH SCOPING , LEXICAL SCOPING , SCOPE AND SCOPE OF A VARIABLE.

-> SCOPING IS THE TERM USED FOR HOW THE VARIABLES ARE ORGANIZED AND ACCESSED IN A CODE .

-> LEXIACAL SCOPING IS KIND A RULE THAT THE GLOBAL SCOPE VARIABLE CAN BE ACCESS INSIDE THE FUNCTION , ALSO INNER FUNCTION CAN ACCESS THIER PARENT FUNCTION VARIABLES. BUT THE VARIABLE CAN'T BE ACCESS OUTSIDE THE INNER SCOPE.

-> SCOPE IS WHERE THE VARIABLE IS DECLARED.

-> SCOPE OF A VARIABLE IS THE REGION OR PIECE WHERE A VARIABLE CAN BE ACCESSED.

*/

/* TYPES OF SCOPE OF VARIABLE:

-> THERE ARE THREE(3) TYPES OF SCOPE:
-> GLOBAL SCOPE , FUNCTION SCOPE AND THE BLOCK SCOPE(ES6).

-> GLOBAL SCOPE VAIABLES ARE DECLARED OUTSIDE OF ANY FUNCTION OR BLOCK AND CAN BE ACCESSED ANYWHERE IN THE CODE.


-> FUNCTION SCOPE VARIABLES ARE DECLARED INSIDE OF A FUNCTION AND CANNOT BE ACCESSED OUTSIDE OF THAT FUNCTION BLOCK.
-> ALSO CALLED LOCAL SCOPE.


-> BLOCK SCOPE VARIABLES ARE DECLARED INSIDE THE BLOCK SCOPE AND CANNOT BE ACCESSED OUTSIDE OF THAT BLOCK EXECPT THE VARIABLE DECALRED WITH VAR.
-> BLOCK SCOPE VARIABLES ARE LET AND CONST.
-> VARIABLE DECALRED WITH VAR CAN BE ACCESSED OUTSIDE OF THAT BLOCK.
-> IT IS INTRODUCED IN ES6.
*/

/*

#

*/

/* THE SCOPE CHAIN:
-> CODE:

   const myName = 'Abuzar';

   function first()
    {
        const age =30;

        if(age >= 30)
         {
            const decade = 3;
            //  WE CANT ACCESS THE DECADE OUTSIDE OF THE BLOCK DUE TO BLOCK SCOPE. 
            var millenial = true;
         }


    function second()
     {
        const job = 'teacher';

         console.log(`${myName} is a ${age} old ${job}`)
    }

        second();
   }
                            
 first();


 -> THERE ARE SOME STEPS IN WHICH THIS CODE IS ORAGNIZED.

 -> IN THE 1ST STEP , THE GLOBAL SCOPE MAKES GLOBAL EXECUTION CONTEXT.

 -> INSIDE THE GLOBAL EXECUTION CONTEXT , THERE IS FIRST FUNCTION IN THE VARIABLE ENVIROMENT.

 -> INSIDE THE FIRST FUNCTION , THERE IS SECOND FUNCTION.

 -> THIS WILL MAKE A NESTED STRUCTURE.

 -> THIS PROCESS IS CALLED VARIABLE LOOKUP IN SCOPE CHAIN.

 -> IN THE SECOND FUNCTION , WE HAVE ACCESSED THE GLOBAL SCOPE VARIABLE AND ALSO THE LOCAL SCOPED VARIABLE AS WELL.

 -> THIS IS DUE TO THE CONCEPT OF SCOPE CHAIN.

 -> IN THE SCOPE CHAIN WE CAN ACCESS ALL THE VARIABLES PRESENT IN THE PARENT CONTEXT.

 -> THE INNER SCOPE HAS ACCESS TO VARIABLES FROM ALL OUTER SCOPES.
 -> THE CHILD SCCOPE HAS ACCESS TO THIER PARENT SCOPE VARIABLES BUT THE PARENT DOESN'T HAVE ACCESS TO THE CHILD SCOPE.
*/

/* IMPORTANT TO NOTE:

-> THE DECADE VARIABLE IN IF BLOCK IS ACTUALLY A BLOCK SCOPE VARIABLE BECAUSE VARIABLES DECLARED WITH CONST AND LET ARE TREATED AS BLOCKED SCOPED VARIABLES IN ES6.

-> IT WILL CREATE THIER OWN SCOPE IN THE EXECUTION CONTEXT.

-> THE MILLINIAL IS NOT A BLOCK SCOPED , VARIABLES DECLARED WITH VAR ARE FUNCTION SCOPED , SO IT IS THE VARIABLE OF FIRST FUNCTION SCOPE.

-> THIS MILLINIAL HAS ALSO ACCESS FOR SECOND OR CHILD FUNCTION.

-> SCOPE CHAIN ALSO APPLIES TO BLOCK SCOPE VARIABLES AND IT HAS ACCESS TO THE OUTER SCOPED VARIABLES.

-> IT DOESN'T HAVE ACCESS TO CHILD SCOPED VARIABLES LIKE SECOND FUNCTION .

-> THE SECOND FUNCTION ALSO DOESN'T HAVE ACCESS TO THE BLOCKED SCOPE VARIABLE.

*/

/*  WHY IS THAT ?

-> WE HAVE LEARNED ABOUT LEXICAL SCOPING CONCEPT.

-> THE SECOND FUNCTION AND IF BLOCK  ARE SIBINGS  AND CHILDS OF ONE FUNCTION.

-> ONE IS NOT WRITTEN INSIDE OF THE ANOTHER.

-> THAT IS THE RULE OF EXICAL SCOPING.

*/

/* IMPORTANT THINGS EXPLAINED:

-> THE SCOPE CHAIN HAS NOTHING TO DO WITH THE ORDER IN WHICH FUNCTIONS WERE CALLED OR THE ORDER OF EXECUTION CONTEXT IN THE CALL STACK.

-> THE SCOPE CHAIN DOES GET THE VARIABLE ENVIROMENT FROM THE EXECUTION CONTEXT.

*/

/* SUMMARY:

-> SCOPING IS THE NAME OF HOW VARIABLE ARE ACCESSED AND ORGANIZED.

-> THERE ARE 3 TYPES OF SCOPE: GLOBAL , FUNCTION(LOCAL) , AND BLOCKED SCOPES.

-> LET AND CONST ARE CONSIDERED AS BLOCKED SCOPED VARIABLES.

-> VARIABLES DECALRED WITH VAR ARE FUNCTION SCOPED.

-> LEXIACL SCOPING IS KIND A RULE OF WHERE WE CAN ACCESS VARIABLES ARE BASED ON EXACTLY WHERE IN THE CODE FUNCTIONS AND BLOCKS ARE WRITTEN.


-> EVERY SCOPE HAS ACCESS TO ALL THE VARIABLES OF OUTER OR PARENT SCOPE.

-> WHEN VARIABLE IS NOT IN THE CURRENT CONTEXT THAT IS ACCESSD INSIDE THAT CONTEXT , THE ENGINE LOOKS UP THE SCOPE UNTIL IT FINDS THE VARIABLES ITS LOOKING FOR. THIS IS CALLED VARIABLE LOOKUP.


-> THE SCOPE CHAIN IS ONE-WAY STREET: A SCOPE WILL NEVER , EVER HAS ACCESS TO THE VARIABLES OF AN INNER SCOPE.

-> THE SCOPE CHAIN HAS NOTHING TO DO WITH ORDER IN WHICH FUNCTIONS WERE CALLED .

-> IT DOESN'T EFFECT THE SCOPE CHAIN AT ALL.

*/
