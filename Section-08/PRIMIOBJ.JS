"use strict";
// PRIMIIVES VS OBJECTS:

/* GENERAL EXPLANATION:

-> CODE :

FOR PRIMITIVES
let age = 30;
let oldAge = age;
age = 40;
console.log(age) // 40
console.log(oldAge) // 30


FOR OBJECTS
const me = {
    name : 'Abuzar',
    age : 20,
};

const friend = me;
friend.age = 30;
console.log(me) // 30
console.log(friend) // 30.

-> THE JS ENGINE STORES PRIMITIVE TYPE IN THE CALL STACK.
-> THE OBJECTS ARE STORED IN THE MEMORY HEAP.

-> PRIMITIVES OR PRIMITIVE TYPES , CONTAIN NUMBERS ,STRINGS , BOOLEANS , UNDEFINED , NULL , SYMBOL AND BIGINT.

-> OBJECTS ARE REFERENCE TYPES CONTAINS OBJECT LITERALS(OBJECTS), ARRAYS , FUNCTIONS , MANY MORE.

-> WE WROTE A CODE :
-> PRIMITIVES : THE VALUE OF AGE IS UPDATED AND HE OLDAGE RMAINS THE SAME.

->OBJECTS : BOTH VALUES ARE UPDATED BY ONLY UPDATED ONE OBJECT VALUE.

-> IT IS BECAUSE OF THE CONCEPT OF MEMORY MANAGEMNET:
*/

/*

#

*/

/* MEMORY MANAGEMENT FOR THE PRIMITIVES:

-> WHEN WE DECLARE A VARIABLE AND ASSIGN IT A VALUE , INSIDE THE CALL STACK , THE VARIABLE NAME IS THE IDENTIFIER , A UNIQUE ADDRESS WILL ASSIGN TO THAT VARIABLE AND ALSO THE VALUE.

IDENTIFIER : (VARIABLE NAME) , ADDRESS : (####) , VALUE : (VALUE)

-> WHEN WE INITIALIZED A VARIABLE , THE VARIABLE WILL SSTORE BY THER ADDRESS.
-> NOW WHEN WE ASSIGN THAT VARIABLE TO NEW VARIABLE  , IT WILL POINT THE ADDRESS OF THAT ASSIGNED VARIABLE AND NOT THE VALUE ITSELF.
-> THE VALUE OF THE ADDRESS CANNOT BE CHANGED.
-> SO THE OLDAGE VARIABLE IS GET ASSIGNED BY THE AGE VARIABLE.
-> IT WILL POINT THE ADDRESS OF THAT VARIABLE AND THE VALUE OF THAT ADDRESS WILL BE STORED AS WELL.

IDENTIFIER2: ,  SAME ADDRESS : (####) , VALUE : (VALUE)



-> THE NEW ADDRESS WILL BE CREATED FOR RE ASSIGNING THE AGE VALUE , AND AGE WILL THEN POINTED TOWARDS THE NEW ADDRESS.
*/

/*

#

*/

/* MEMORY MANAGEMENT FOR OBJECTS.

-> THE MEMORY OF OBJECTS IS SIMPLE.

-> WHEN WE CREATE AN OBJECT , THE IDENTIFIER WILL GET ASSIGNED AN ADDRESS IN THE CALL STACK AND THE VALUE OF THAT ADDRESS WIL BE THE ADRESS OF THAT OBJECT IN THE MEMORY HEAP WHICH WILL BE THE ADDRESS OF THE VALUE OF THAT OBJECT.
-> THAT IS WHY IT IS CALLED THE REFERENCE VALUES.

-> THE VALUE OF THE OBJECT IN THE CALL STACK WILL BE THE REFERENCE TO THE ADRESS IN THE MEMORY HEAP.

-> SINCE THE FRIEND OBJECT IS POINTING TO THE SAME ADDRESS AND THAT IS REFERENCE TO THAT OBJECT VALUE IN THE MEMORY HEAP.
-> SO WHEN THE FIREND OBJECT UPDATE THIER OWN KEY VALUE.

-> THE VALUE DIDN'T CHANGED IN THE CALL STACK.
-> THE VALUE ONLY CHANGE INSIDE THE MEMORY HEAP.
-> SO MEMORY HEAP VALUE IS SAME FOR THE FIRST OBJECT AS WELL.
-> SO IT WILL CHANGE THE VALUE OF THAT OBJECT AS WELL.


CALL STACK:
IDENTIFIER : (VARIABLE NAME) , ADDRESS : (####) , VALUE : (mem Address)



MEMORY HEAP:

ADDRESS : (####) , VALUE : (KEY VALUES.)


*/
