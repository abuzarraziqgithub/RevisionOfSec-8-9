"use strict";

/* GENERAL EXPLANATION:

-> CLOSURE IS THE IMPORTANT CONCEPT IN JAVASCRIPT.
-> CLOSURE MAKES THE FUNCTION REMEMBER ALL THE VARIABLES THAT ARE EXISTED AT THIER PARENT FUNCTION WHICH HAS BEEN EXECUTED.

-> THIS CONCEPT IS WHEN THE FUNCTION RETURNING ANOTHER FUNCTION.

-> THE VARIABLE THAT IS DECLARED IN THE PARENT FUNCTION AND ALSO ASSIGN THAT VARIABLE IN THE RETUNING FUNCTION .
-> WHEN WE STORE THE PARENT FUNCTION INTO A VARIABLE. TAT VARIABLE WILL RETURN THE CHILD FUNCTION BECAUSE THE PARENT FUNCTION HAS BEEN EXECUTED . NOW WHEN WE RETURN THAT CHILD FUNCTION , IT WILL HAVE THE VARIABLE OF THAT PARENT FUNCTION WHICH HAS BEEN EXECUTED BEFORE , BUT SOMEHOW THE CHILD(RETURNING) FUNCTION HAS ACCESS TO THAT VARIABLE EVEN AFTER THE FUNCTION NOT EVEN EXISTED.


-> NOW , BEHIND THE SCENES , THE FUNCTION WHICH IS IN THE EXECUTION CONTEXT OF PARENT FUNCTION ALSO HAS ACCESS TO VARIABLES OF PARENT FUNCTION.

-> IT ALWAYS HAS ACCESS TO THE VARIABLE ENVIROMENT OF THE EXECUTION CONTEXT IN WHICH IT WAS CRETED EVEN AFTER THAT EXECUTION CONTEXT IS GONE.

-> THE CLOSURE HAS PRIORITY OVER SCOPE CHAIN , BECAUSE IF WE CREATE A VARIABLE IN THE GLOBAL SCOPE THAT HAS BEEN CREATED IN THE FUNCTION SCOPE BEFORE. IT WILL STIL USE THE FIRST(FUNCTION) VARIABLE THAT IS IN FUNCTION SCOPE.

-> IT CLOSED-OVER THE VARIABLE ENVIROMENT OF THIER PARENT FUNCTION EXECUTION CONTEXT IN WHICH THIS RETURN FUNCTION WAS CRETED EVEN AFTER THAT EXECUTION CONTEXT IS GONE.

-> THE CHILD FUNCTION KEEPS REFERENCE TO IT'S PARENT SCOPE WHICH PRESERVES THE SCOPE CHAIN THROUGHOUT TIME.

-> A CLOSURE MAKES SURE THAT A FUNCTION DOESN'T LOOSE CONNECTION TO VARIABLE THAT EXISTED AT THE FUNCTION BIRTHPLACE.

-> CLOSURE IS NOT A MNUAL CONCEPT , IT DOES AUTOMATICALLY , WHEN WE RETURN FUNCTION FROM A FUNCTION AND USE THE VARIABLE OF OUTER FUNCTION IN INNER FUNCTION.

*/

const secureBooking = () => {
  let passengerCount = 0;

  return () => {
    passengerCount++;
    console.log(`${passengerCount} Passenger!`);
  };
};

const booker = secureBooking();
booker(); // 1 Passenger
booker(); // 2 passenger

// EXAMPLE 2
let f;
const g = () => {
  const a = 2;
  f = () => console.log(a * 2);
};

const h = () => {
  const b = 20;
  f = () => console.log(b * 2);
};

g(); // PARENT FUNCTION HAS BEEM CALLED AND EXECUTED.
h(); // 4  THIS FUNCTION IS NOW ACT AS A SIMPLE FUNCTION , MEANS THAT IT WILL NOT GET US AN ERROR OF h() IS NOT A FUNCTION ETC, BECAUSE IT IS NOW ACT AS AN OUTER FUNCTION AFTER THE PARENT FUNCTION IS EXECUTED.

// RE ASSIGNING f FUNCTION:
h();
f(); // THIS IS ENTIRE NEW FUNCTION.

// EXAMPLE 3:
const boardPassengers = (n, wait) => {
  const perGroup = n / 3;

  setTimeout(() => {
    console.log(`WE ARE NOW BOARDING ALL ${n} PASEENGERS`);
    console.log(`THERE ARE 3 GROUPS , EACH WITH ${perGroup} PASSENGERS`);
  }, wait * 1000);

  console.log(`WILL START BOARDING IN ${wait} SECONDS`);
};

boardPassengers(3, 4);
